---
title: "autocorr"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggraph)
library(tidygraph)
library(foreach)
library(doParallel)
library(mlr)
library(cowplot)
library(rfUtilities)
library(lme4)

registerDoParallel(cores=12)

fn_par_bootstrap = function(fn, reps=200, ...) {
  df_results = foreach(
    i=1:reps,
    .combine=rbind
  ) %dopar% {
    result = fn(...)
    result$rep = i
    return(result)
  }
  return(df_results)
}

```

### Compare different methods for dealing with non-randomly selected samples

```{r}
fn_full_ego_then_alter_scoring = function() {
  g = fn_dgp_ipw()

  df_edges = g %>% activate(edges) %>%
    as_tibble()
  
  mod_ego = glm(
    Y_ego ~ X_ego + X_nbr + outdeg_inv_ego + outdeg_ego + indeg_nbr,
    data=df_edges %>%
      filter(gt_ego == 1),
    family=binomial()
  )
  df_edges$Y_ego_hat = predict(
    mod_ego,
    newdata=df_edges,
    type='response'
  )
  
  mod_nbr = glm(
    Y_nbr ~ X_ego + X_nbr + outdeg_inv_ego + outdeg_ego + indeg_nbr + Y_ego_hat,
    data=df_edges %>%
      filter(gt_nbr == 1),
    family=binomial()
  )
  df_edges$Y_nbr_hat = predict(
    mod_nbr,
    newdata = df_edges,
    type='response'
  )
  
  return(
    data.frame(
      y_true=sum(df_edges$outdeg_inv_ego * df_edges$Y_ego * df_edges$Y_nbr),
      y_hat=sum(df_edges$outdeg_inv_ego * df_edges$Y_ego_hat * df_edges$Y_nbr_hat)
    ) %>%
      mutate(
        y_relative_err=(y_hat - y_true) / y_true
      )
  )
}

fn_sample_only = function() {
  g = fn_dgp_ipw()

  df_edges = g %>% activate(edges) %>%
    as_tibble() %>%
    mutate(
      Y = Y_ego * Y_nbr
    )
  df_samp = df_edges %>%
    filter(gt == 1)

  return(
    data.frame(
      y_true=sum(df_edges$outdeg_inv_ego * df_edges$Y_ego * df_edges$Y_nbr),
      y_hat=sum(df_samp$outdeg_inv_ego * df_samp$Y_ego * df_samp$Y_nbr)
    ) %>%
      mutate(
        y_relative_err=(y_hat - y_true) / y_true
      )
  )
}

fn_ipw = function() {
  g = fn_dgp_ipw()

  df_edges = g %>% activate(edges) %>%
    as_tibble() %>%
    mutate(
      Y = Y_ego * Y_nbr
    )
  mod_incl = glm(
    gt ~ Q_ego * Q_nbr,
    data=df_edges,
    family=binomial()
  )
  df_edges$weights = 1/predict(mod_incl, type='response')

  mod = glm(
    Y ~ X_ego + X_nbr + outdeg_inv_ego + outdeg_ego + indeg_nbr,
    data=df_edges %>%
      filter(gt == 1),
    family=binomial(),
    weights=weights
  )
  
  preds = predict(
    mod,
    newdata = df_edges,
    type='response'
  )
  
  return(
    data.frame(
      y_true=sum(df_edges$outdeg_inv_ego * df_edges$Y_ego * df_edges$Y_nbr),
      y_hat=sum(df_edges$outdeg_inv_ego * preds)
    ) %>%
      mutate(
        y_relative_err=(y_hat - y_true) / y_true
      )
  )
}

```

```{r}
df_ipw = fn_par_bootstrap(
  fn_ipw,
  reps=200
)

df_score_ego_then_alter = fn_par_bootstrap(
  fn_full_ego_then_alter_scoring,
  reps=200
)

df_sample = fn_par_bootstrap(
  fn_sample_only,
  reps=200
)
```


```{r}
df_plot = bind_rows(
  df_ipw %>%
    mutate(kind='ipw'),
  df_sample %>%
    mutate(kind='sample'),
  df_score_ego_then_alter %>%
    mutate(kind='score_ego_then_alter')
)

df_plot %>%
  ggplot(aes(x=kind, y=y_relative_err)) +
  geom_boxplot()

df_plot %>%
  ggplot(aes(x=kind, y=abs(y_relative_err))) +
  geom_boxplot()
```


## Joint


```{r}
fn_joint = function() {
  g = fn_dgp_ipw()
  
  df_nodes = g %>%
    activate(nodes) %>%
    as_tibble()
  
  df_edges = g %>%
    activate(edges) %>%
    as_tibble()
  
  mod = glm(
    gt ~ Q_ego + Q_nbr + outdeg_nbr + indeg_ego,
    data=df_edges,
    family=binomial()
  )
  df_edges$gt_prob = predict(mod, type='response')
  #df_edges$gt_prob = probability.calibration(
  #  df_edges$gt,
  #  df_edges$Q_prob_ego * df_edges$Q_prob_nbr
  #)
  
  df = df_edges %>%
    mutate(
      cats=cut(
        gt_prob,
        breaks=seq(0, 1, 0.05)
      )
    ) %>%
    group_by(cats) %>%
    summarize(
      predicted=mean(gt_prob),
      empirical=mean(gt),
    )
  return( data.frame(mse=sqrt(mean((df$predicted - df$empirical)^2)) ))
}
res = fn_par_bootstrap(fn_joint, 200)
mean(res$mse)
```

## Edge

```{r}
fn_edge = function() {
  g = fn_dgp_edge()
  
  df_nodes = g %>%
    activate(nodes) %>%
    as_tibble()
  
  df_edges = g %>%
    activate(edges) %>%
    as_tibble() %>%
    mutate(
      Y = as.integer(Y_ego & Y_nbr)
    )
  
  mod = glm(
    gt ~ Q + X_ego + X_nbr + outdeg_inv_ego + outdeg_ego + indeg_nbr,
    family='binomial',
    df_edges
  )
  df_edges$gt_prob = predict(mod, type='response')
  df = df_edges %>%
  mutate(
    cats=cut(
      gt_prob,
      breaks=seq(0, 1, 0.05)
    )
  ) %>%
  group_by(cats) %>%
  summarize(
    predicted=mean(gt_prob),
    empirical=mean(gt),
  )
  return( data.frame(mse=sqrt(mean((df$predicted - df$empirical)^2)) ))
}
res = fn_par_bootstrap(fn_edge, 200)
mean(res$mse)
```

## Ego

```{r}
fn_ego = function() {
  g = fn_dgp_ipw()
  
  df_nodes = g %>%
    activate(nodes) %>%
    as_tibble()
  
  df_edges = g %>%
    activate(edges) %>%
    as_tibble()
  
  mod = glm(
    gt ~ Q,
    data=df_nodes,
    family=binomial()
  )
  
  df_nodes$gt_prob = predict(mod, type='response')
  
  df_edges$gt_prob = df_nodes$gt_prob[df_edges$from] * df_nodes$gt_prob[df_edges$to]
  
  df = df_edges %>%
    mutate(
      cats=cut(
        gt_prob,
        breaks=seq(0, 1, 0.05)
      )
    ) %>%
    group_by(cats) %>%
    summarize(
      predicted=mean(gt_prob),
      empirical=mean(gt),
    )
  return( data.frame(mse=sqrt(mean((df$predicted - df$empirical)^2)) ))
}
res = fn_par_bootstrap(fn_ego, 200)
mean(res$mse)
```


## Ego

```{r}
fn_direct = function() {
  g = fn_dgp_ipw()
  
  df_nodes = g %>%
    activate(nodes) %>%
    as_tibble()
  
  df_edges = g %>%
    activate(edges) %>%
    as_tibble() %>%
    mutate(
      gt_prob = Q_prob_ego * Q_prob_nbr
    )
  
  df = df_edges %>%
    mutate(
      cats=cut(
        gt_prob,
        breaks=seq(0, 1, 0.05)
      )
    ) %>%
    group_by(cats) %>%
    summarize(
      predicted=mean(gt_prob),
      empirical=mean(gt),
    )
  return( data.frame(mse=sqrt(mean((df$predicted - df$empirical)^2)) ))
}
res = fn_par_bootstrap(fn_direct, 200)
mean(res$mse)
```



```{r}
g = fn_dgp_ipw()

df_nodes = g %>%
  activate(nodes) %>%
  as_tibble()

df_edges = g %>%
  activate(edges) %>%
  as_tibble()

mod = glm(
  gt ~ Q_ego + Q_nbr,
  data=df_edges,
  family=binomial()
)
df_edges$gt_prob = predict(mod, type='response')


```


## Scratch

```{r}
g = fn_dgp_ipw(size=10000)
bin = 0.05

df_nodes = g %>%
  activate(nodes) %>%
  as_tibble()

df_edges = g %>%
  activate(edges) %>%
  as_tibble() %>%
  mutate(
    gt_prob = Q_prob_ego * Q_prob_nbr
  )

bind_rows(
  df_edges %>%
    mutate(
      cats=cut(
        gt_prob,
        breaks=seq(0, 1, bin),
      )
    ) %>%
    group_by(cats) %>%
    summarize(
      predicted=mean(gt_prob),
      empirical=mean(gt),
      rel=empirical/predicted,
      n=n(),
      kind='indep'
    )
) %>%
  ggplot(aes(x=cats, y=rel, color=kind)) +
  geom_hline(yintercept=1, linetype='dotdash', alpha=0.2) +
  geom_point() +
  theme_cowplot()


bind_rows(
  df_edges %>%
    mutate(
      cats=cut(
        gt_prob,
        breaks=seq(0, 1, bin),
      )
    ) %>%
    group_by(cats) %>%
    summarize(
      predicted=mean(gt_prob),
      empirical=mean(gt),
      rel=empirical,
      n=n(),
      kind='indep'
    )
) %>%
  ggplot(aes(x=cats, y=rel, color=kind)) +
  geom_hline(yintercept=1, linetype='dotdash', alpha=0.2) +
  geom_abline(intercept=-bin/2, slope=bin, linetype='dotdash') +
  geom_point() +
  theme_cowplot()
```


```{r}
fn_default_scoring = function() {
  g = fn_dgp_ipw()

  df_edges = g %>% activate(edges) %>%
    as_tibble() %>%
    mutate(
      Y = Y_ego * Y_nbr
    )
  
  mod = glm(
    Y ~ X_ego + X_nbr,
    data=df_edges %>%
      filter(gt == 1),
    family=binomial()
  )
  
  preds = predict(
    mod,
    newdata = df_edges,
    type='response'
  )
  
  return(
    data.frame(
      y_true=sum(df_edges$outdeg_inv_ego * df_edges$Y_ego * df_edges$Y_nbr),
      y_hat=sum(preds * df_edges$outdeg_inv_ego)
    ) %>%
      mutate(
        y_relative_err=(y_hat - y_true) / y_true
      )
  )
}

fn_full_model_scoring = function() {
  g = fn_dgp_ipw()

  df_edges = g %>% activate(edges) %>%
    as_tibble() %>%
    mutate(
      Y = Y_ego * Y_nbr
    )
  
  mod = glm(
    Y ~ X_ego + X_nbr + outdeg_inv_ego + outdeg_ego + indeg_nbr,
    data=df_edges %>%
      filter(gt == 1),
    family=binomial()
  )
  
  preds = predict(
    mod,
    newdata = df_edges,
    type='response'
  )
  
  return(
    data.frame(
      y_true=sum(df_edges$outdeg_inv_ego * df_edges$Y_ego * df_edges$Y_nbr),
      y_hat=sum(preds * df_edges$outdeg_inv_ego)
    ) %>%
      mutate(
        y_relative_err=(y_hat - y_true) / y_true
      )
  )
}






fn_score_weights = function() {
  g = fn_dgp_ipw()

  df_edges = g %>% activate(edges) %>%
    as_tibble() %>%
    mutate(
      Y = Y_ego * Y_nbr
    )
  mod_incl = glm(
    gt ~ X_ego + X_nbr + outdeg_inv_ego + outdeg_ego + indeg_nbr,
    data=df_edges,
    family=binomial()
  )
  df_edges$weights = 1/predict(mod_incl, type='response')

  mod = glm(
    Y ~ X_ego + X_nbr + outdeg_inv_ego + outdeg_ego + indeg_nbr,
    data=df_edges %>%
      filter(gt == 1),
    family=binomial(),
    weights=weights
  )
  
  preds = predict(
    mod,
    newdata = df_edges,
    type='response'
  )
  
  return(
    data.frame(
      y_true=sum(df_edges$outdeg_inv_ego * df_edges$Y_ego * df_edges$Y_nbr),
      y_hat=sum(df_edges$outdeg_inv_ego * preds)
    ) %>%
      mutate(
        y_relative_err=(y_hat - y_true) / y_true
      )
  )
}
```

