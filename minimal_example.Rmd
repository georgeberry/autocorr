## A minimal example

Example of one full loop of the process, good for developing or understanding

```{r setup, include=FALSE}
library(tidyverse)
library(ggraph)
library(tidygraph)
library(foreach)
library(doParallel)
library(pROC)
library(caret)
source("/Users/georgeberry/Dropbox/project-autocorr/autocorr/sim_code.R")

registerDoParallel(cores=10)
N_SIMS = 100
N_NODES = 4000
N_GROUND_TRUTH_NODES = 500
POWERLAW_EXPONENT = 0.8
EDGES_PER_NEW_NODE = 5
MAJORITY_GROUP_FRAC = 0.7
SAME_GRP_COEF = 0.7
NOISE_COEF = 0.2
```


# new graph

```{r}
play_undir_powerlaw_homophily_graph = function(
    n_nodes,
    edges_per_node,
    majority_group_frac,
    powerlaw_exponent,
    same_grp_coef
) {

    majority_N = round(n_nodes * majority_group_frac)
    majority_Y = rep(1, majority_N)
    majority_Z = rnorm(majority_N, 0, 1)
    majority_X = 1 + majority_Z

    minority_N = round(n_nodes * (1 - majority_group_frac))
    minority_Y = rep(0, minority_N)
    minority_Z = rnorm(minority_N, 0, 1)
    minority_X = -1 + minority_Z

    # Group
    Y = c(majority_Y, minority_Y)

    X = c(majority_X, minority_X)

    Z = c(majority_Z, minority_Z)

    nodes = 1:n_nodes

    node_df = data.frame(
        Y=Y,
        X=X
    )

    # Degree
    D = list()
    for (node in nodes) {
        D[[node]] = 0
    }

    # seed nodes are chose at random and completely connected (clique)
    # edges_per_node is also the number of seeds
    seeds = sample(nodes, edges_per_node, replace=FALSE)

    for (seed in seeds) {
        D[[seed]] = edges_per_node
    }

    edge_df = expand.grid(seeds, seeds)
    colnames(edge_df) = c('from', 'to')

    node_iter_order = sample(
      setdiff(nodes, seeds),
      length(setdiff(nodes, seeds)),
      replace=FALSE
    )

    for (node in node_iter_order) {
        node_grp = Y[node]
        same_grp_nodes = as.integer(Y == node_grp)
        for (edge_to_add in 1:edges_per_node) {
            # Determining a connection is a function of
            # degree, group_Y, Z

            # Using the conditional logit expression in Overgoor et al 2020
            deg_probs = exp(
              powerlaw_exponent * log(unlist(D)) +
              same_grp_coef * same_grp_nodes
            )
            probs = deg_probs / sum(deg_probs)

            draw = sample(nodes, 1, replace=FALSE, prob=probs)
            while (draw == node) {
                # if you sample yourself, redraw
                draw = sample(nodes, 1, replace=FALSE, prob=probs)
            }

            edge_df = bind_rows(
                edge_df,
                data.frame(from=c(node, draw), to=c(draw, node))
            )
            D[[node]] = D[[node]] + 1
            D[[draw]] = D[[draw]] + 1
        }
    }
    return(
        as_tbl_graph(edge_df)  %>%
            activate(nodes) %>%
            mutate(
                Y=Y[as.integer(name)],
                X=X[as.integer(name)],
                Z=Z[as.integer(name)]
            )
    )
}


fn_new_dgp_main_node_degsamp = function() {
  # Creates a graph and draws Y = f(X, Z), where X ~ N(0, 1) and
  # Z is the ego-network avg of the observed X
  g = play_undir_powerlaw_homophily_graph(
    N_NODES,
    EDGES_PER_NEW_NODE,
    MAJORITY_GROUP_FRAC,
    POWERLAW_EXPONENT,
    SAME_GRP_COEF
  )
  g = g %>%
    activate(nodes) %>%
    mutate(
      outdeg = centrality_degree(mode='out'),
      outdeg_inv = 1 / outdeg,
      indeg = centrality_degree(mode='in'),
      indeg_inv = 1 / indeg,
    )

  tmp = g %>%
    activate(nodes) %>%
    as_tibble() %>%
    select(name, outdeg) %>%
    mutate(pr = outdeg / sum(outdeg))
  gt_nodes = sample(
    tmp$name,
    N_GROUND_TRUTH_NODES,
    replace=FALSE,
    prob=tmp$pr
  )
    
  g = g %>%
    mutate(
      gt = as.integer(name %in% gt_nodes)
    ) %>%
    activate(edges) %>%
    mutate(
      Y_ego = .N()$Y[from],
      Y_nbr = .N()$Y[to],
      Y = Y_ego * Y_nbr,
      indeg_ego = .N()$indeg[from],
      indeg_nbr = .N()$indeg[to],
      outdeg_ego = .N()$outdeg[from],
      outdeg_nbr = .N()$outdeg[to],
      indeg_inv_ego = .N()$indeg_inv[from],
      indeg_inv_nbr = .N()$indeg_inv[to],
      outdeg_inv_ego = .N()$outdeg_inv[from],
      outdeg_inv_nbr = .N()$outdeg_inv[to],
      gt_ego = .N()$gt[from],
      gt_nbr = .N()$gt[to],
      gt = as.numeric(gt_ego & gt_nbr),
      X_ego = .N()$X[from],
      X_nbr = .N()$X[to],
    )
  return(g)
}





fn_test_reps = function(fn_g) {
  g = fn_g()
  
  # true vals
  df_nodes = g %>% activate(nodes) %>% as_tibble()
  df_edges = g %>% activate(edges) %>% as_tibble()
  Y_true = sum(df_edges$outdeg_inv_ego * df_edges$Y)
  
  # mod 1
  df_nodes = g %>% activate(nodes) %>% as_tibble()
  df_edges = g %>% activate(edges) %>% as_tibble()
  mod1 = glm(
    Y_ego ~ X_ego * outdeg_inv_ego +
      X_ego * outdeg_inv_nbr +
      X_nbr * outdeg_inv_ego +
      X_nbr * outdeg_inv_nbr +
      outdeg_ego +
      outdeg_nbr,
    data=df_edges %>%
      filter(gt_ego == 1),
    family=binomial()
  )
  df_edges$Y_ego_hat = predict(mod1, newdata=df_edges, type='response')
  df_edges %>%
    left_join(
      df_edges %>%
        select(from, to, Y_nbr_hat=Y_ego_hat),
      by=c('from'='to', 'to'='from')
    ) ->
    df_edges
  Y_hat_mod1 = sum(
    df_edges$outdeg_inv_ego *
    df_edges$Y_ego_hat *
    df_edges$Y_nbr_hat
  )
  df_edges$e_ego = df_edges$Y_ego - df_edges$Y_ego_hat
  df_edges$e_nbr = df_edges$Y_nbr - df_edges$Y_nbr_hat
  b1_mod1=sum(df_edges$outdeg_inv_ego * df_edges$Y_ego_hat * df_edges$e_nbr)
  b2_mod1=sum(df_edges$outdeg_inv_ego * df_edges$Y_nbr_hat * df_edges$e_ego)
  e_mod1=sum(df_edges$outdeg_inv_ego * df_edges$e_ego * df_edges$e_nbr)
  b1_raw_mod1=sum(df_edges$Y_ego_hat * df_edges$e_nbr)
  b2_raw_mod1=sum(df_edges$Y_nbr_hat * df_edges$e_ego)
  
  # mod 2
  df_nodes = g %>% activate(nodes) %>% as_tibble()
  df_edges = g %>% activate(edges) %>% as_tibble()
  mod2 = glm(
    Y_ego ~ X_ego +
      X_nbr +
      outdeg_inv_ego +
      outdeg_inv_nbr +
      outdeg_ego +
      outdeg_nbr,
    data=df_edges %>%
      filter(gt_ego == 1),
    family=binomial()
  )
  df_edges$Y_ego_hat = predict(mod2, newdata=df_edges, type='response')
  df_edges %>%
    left_join(
      df_edges %>%
        select(from, to, Y_nbr_hat=Y_ego_hat),
      by=c('from'='to', 'to'='from')
    ) ->
    df_edges
  Y_hat_mod2 = sum(
    df_edges$outdeg_inv_ego *
    df_edges$Y_ego_hat *
    df_edges$Y_nbr_hat
  )
  df_edges$e_ego = df_edges$Y_ego - df_edges$Y_ego_hat
  df_edges$e_nbr = df_edges$Y_nbr - df_edges$Y_nbr_hat
  b1_mod2=sum(df_edges$outdeg_inv_ego * df_edges$Y_ego_hat * df_edges$e_nbr)
  b2_mod2=sum(df_edges$outdeg_inv_ego * df_edges$Y_nbr_hat * df_edges$e_ego)
  e_mod2=sum(df_edges$outdeg_inv_ego * df_edges$e_ego * df_edges$e_nbr)
  b1_raw_mod2=sum(df_edges$Y_ego_hat * df_edges$e_nbr)
  b2_raw_mod2=sum(df_edges$Y_nbr_hat * df_edges$e_ego)
  

  return(
    data.frame( 
      Y_true=Y_true,
      
      Y_hat_mod1=Y_hat_mod1,
      b1_mod1=b1_mod1,
      b2_mod1=b2_mod1,
      e_mod1=e_mod1,
      b1_raw_mod1=b1_raw_mod1,
      b2_raw_mod1=b2_raw_mod1,
      
      Y_hat_mod2=Y_hat_mod2,
      b1_mod2=b1_mod2,
      b2_mod2=b2_mod2,
      e_mod2=e_mod2,
      b1_raw_mod2=b1_raw_mod2,
      b2_raw_mod2=b2_raw_mod2
    )
  )
}
```

```{r}
fn_test_reps(fn_new_dgp_main_node_degsamp)
```


```{r}
tmp = fn_par_run(fn_test_reps, 50, fn_new_dgp_main_node_degsamp)
```

```{r}
mean(tmp$Y_true - tmp$Y_hat_mod1)
```

```{r}
tmp %>% summarize_all(mean) %>% View()
```


```{r}
g = fn_new_dgp_main_node_degsamp()
df_nodes = g %>% activate(nodes) %>% as_tibble()
df_edges = g %>% activate(edges) %>% as_tibble()
```


```{r}
g %>%
  activate(nodes) %>%
  as_tibble() %>%
  mutate(outdeg=outdeg + 0.001 * rnorm(n())) %>%
  ggplot(aes(x=log(rank(-outdeg)), y=log(outdeg))) +
  geom_point()
```


### Testing implications of sampling proportional to node degree

```{r}
df_nodes %>%
  select(name, outdeg) %>%
  mutate(
    pr=outdeg/sum(outdeg),
  ) -> tmp

samp = sample(tmp$name, 1000, replace=FALSE, prob=tmp$pr)

df_edges %>%
  mutate(
    idx=1:n()
  ) %>%
  filter(
    from %in% samp
  ) %>%
  summarize(mean(idx))
```
