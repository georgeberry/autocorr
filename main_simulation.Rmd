---
title: "minexamp"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggraph)
library(tidygraph)
library(foreach)
library(doParallel)
library(pROC)
library(cowplot)
library(caret)
library(xtable)

registerDoParallel(cores=12)

fn_par_bootstrap = function(fn, n_reps, ...) {
  df_results = foreach(
    i=1:n_reps,
    .combine=rbind
  ) %dopar% {
    result = fn(...)
    result$rep = i
    return(result)
  }
  return(df_results)
}
```

```{r}
fn_dgp_corr_nodesamp = function(n_nodes=4000, node_samp_frac=0.2) {
  # Creates a graph and draws Y = f(X, Z), where X ~ N(0, 1) and
  # Z is the ego-network avg of the observed X
  g = play_barabasi_albert(n_nodes, 0.8, 5)
  g = g %>%
    bind_edges(
      g %>%
        activate(edges) %>%
        as_tibble() %>%
        mutate(tmp=to, to=from, from=tmp) %>%
        select(to, from)
    ) %>%
    activate(nodes) %>%
    mutate(
      X = rnorm(n()),
      # ZZ = rnorm(n()), 
      Z = map_local_dbl(
        .f = function(neighborhood, ...) {
          max(as_tibble(neighborhood, active='nodes')$X)
        }
      ),
      Z = (Z - mean(Z)) / sd(Z),
      outdeg = centrality_degree(mode='out'),
      Y_prob_true = 1 / (1 + exp(- 2 * X - Z)), #  - log1p(outdeg))),
      outdeg_inv = 1 / outdeg,
      indeg = centrality_degree(mode='in'),
      indeg_inv = 1 / indeg,
      Y = rbinom(
        n(),
        1,
        Y_prob_true
      ),
      gt = rbinom(n(), 1, node_samp_frac)
    ) %>%
    activate(edges) %>%
    mutate(
      Y_ego = .N()$Y[from],
      Y_nbr = .N()$Y[to],
      Y = Y_ego * Y_nbr,
      indeg_ego = .N()$indeg[from],
      indeg_nbr = .N()$indeg[to],
      outdeg_ego = .N()$outdeg[from],
      outdeg_nbr = .N()$outdeg[to],
      indeg_inv_ego = .N()$indeg_inv[from],
      indeg_inv_nbr = .N()$indeg_inv[to],
      outdeg_inv_ego = .N()$outdeg_inv[from],
      outdeg_inv_nbr = .N()$outdeg_inv[to],
      gt_ego = .N()$gt[from],
      gt_nbr = .N()$gt[to],
      gt = as.numeric(gt_ego & gt_nbr),
      X_ego = .N()$X[from],
      X_nbr = .N()$X[to],
    )
  return(g)
}


fn_dgp_corr_edgesamp = function(n_nodes=4000, edge_samp_frac=0.05) {
  # Creates a graph and draws Y = f(X, Z), where X ~ N(0, 1) and
  # Z is the ego-network avg of the observed X
  g = play_barabasi_albert(n_nodes, 0.8, 5)
  g = g %>%
    bind_edges(
      g %>%
        activate(edges) %>%
        as_tibble() %>%
        mutate(tmp=to, to=from, from=tmp) %>%
        select(to, from)
    ) %>%
    activate(nodes) %>%
    mutate(
      X = rnorm(n()),
      # ZZ = rnorm(n()), 
      Z = map_local_dbl(
        .f = function(neighborhood, ...) {
          max(as_tibble(neighborhood, active='nodes')$X)
        }
      ),
      Z = (Z - mean(Z)) / sd(Z),
      outdeg = centrality_degree(mode='out'),
      Y_prob_true = 1 / (1 + exp(- 2 * X - Z)), #  - log1p(outdeg))),
      outdeg_inv = 1 / outdeg,
      indeg = centrality_degree(mode='in'),
      indeg_inv = 1 / indeg,
      Y = rbinom(
        n(),
        1,
        Y_prob_true
      )
    ) %>%
    activate(edges) %>%
    mutate(
      Y_ego = .N()$Y[from],
      Y_nbr = .N()$Y[to],
      Y = Y_ego * Y_nbr,
      indeg_ego = .N()$indeg[from],
      indeg_nbr = .N()$indeg[to],
      outdeg_ego = .N()$outdeg[from],
      outdeg_nbr = .N()$outdeg[to],
      indeg_inv_ego = .N()$indeg_inv[from],
      indeg_inv_nbr = .N()$indeg_inv[to],
      outdeg_inv_ego = .N()$outdeg_inv[from],
      outdeg_inv_nbr = .N()$outdeg_inv[to],
      # sample at edge level
      gt = rbinom(n(), 1, edge_samp_frac),
      X_ego = .N()$X[from],
      X_nbr = .N()$X[to],
    ) %>%
    # for any node who is part of a gt edge, give that node gt=1
    activate(nodes) %>%
    mutate(
      # if any edge containing the focal node is 1, the node is gt=1
      gt=map_local_dbl(
        .f = function(neighborhood, node, ...) {
          df_tmp = as_tibble(neighborhood, active='edges') %>%
            filter(gt==1)
          min(nrow(df_tmp), 1) # if 0 in gt, return 0 else 1
        }
      )
    ) %>%
    # now go back and label the gt_ego/gt_nbr based on the node being included
    # in any ground-truth edge
    activate(edges) %>%
    mutate(
      gt_ego = .N()$gt[from],
      gt_nbr = .N()$gt[to],
    )
    
  return(g)
}


fn_oos = function(fn_g) {
  # fit 4 models
  # node
  # edge
  # ego-then-alter
  # ego-then-alter (with prob passed to alter model)
  
  g = fn_g()
  df_nodes = g %>% activate(nodes) %>% as_tibble()
  df_edges = g %>% activate(edges) %>% as_tibble()

  # node no network features
  node_mod = glm(
    Y ~ X, # + log1p(outdeg),
    family='binomial',
    data=df_nodes %>%
      filter(gt == 1)
  )
  node_preds = predict(node_mod, newdata=df_nodes, type='response')
  Y_hat_node_nonetwork = sum(
    df_edges$outdeg_inv_ego *
    node_preds[df_edges$from] *
    node_preds[df_edges$to]
  )
  node_mod = glm(
    Y ~ X + outdeg_inv + outdeg,
    family='binomial',
    data=df_nodes %>%
      filter(gt == 1)
  )
  node_preds = predict(node_mod, newdata=df_nodes, type='response')
  Y_hat_node = sum(
    df_edges$outdeg_inv_ego *
    node_preds[df_edges$from] *
    node_preds[df_edges$to]
  )
  
  # edge
  edge_mod = glm(
    Y ~ X_ego + X_nbr + outdeg_ego + indeg_nbr + outdeg_inv_ego,
    family='binomial',
    data=df_edges %>%
      filter(gt == 1)
  )
  Y_hat_edge = sum(
    df_edges$outdeg_inv_ego *
    predict(edge_mod, newdata=df_edges, type='response')
  )
  
  # ego then alter
  ego_mod = glm(
    Y_ego ~ X_ego + X_nbr + outdeg_ego + indeg_nbr + outdeg_inv_ego,
    family='binomial',
    data=df_edges %>%
      filter(gt_ego == 1)
  )
  df_edges$Y_ego_hat = predict(ego_mod, newdata=df_edges, type='response')
  nbr_mod = glm(
    Y_nbr ~ X_ego + X_nbr + outdeg_ego + indeg_nbr + outdeg_inv_ego,
    family='binomial',
    data=df_edges %>%
      filter(gt_nbr == 1)
  )
  df_edges$Y_nbr_hat = predict(nbr_mod, newdata=df_edges, type='response')
  Y_hat_egoalter = sum(
    df_edges$outdeg_inv_ego *
    df_edges$Y_ego_hat *
    df_edges$Y_nbr_hat
  )
  
  # clear
  df_edges$Y_ego_hat = NULL
  df_edges$Y_nbr_hat = NULL
  
  # ego then alter with prob passed
  ego_mod = glm(
    Y_ego ~ X_ego + X_nbr + outdeg_ego + indeg_nbr + outdeg_inv_ego,
    family='binomial',
    data=df_edges %>%
      filter(gt_ego == 1)
  )
  df_edges$Y_ego_hat = predict(ego_mod, newdata=df_edges, type='response')
  nbr_mod = glm(
    Y_nbr ~ X_ego + X_nbr + outdeg_ego + indeg_nbr + outdeg_inv_ego + Y_ego_hat,
    family='binomial',
    data=df_edges %>%
      filter(gt_nbr == 1)
  )
  df_edges$Y_nbr_hat = predict(nbr_mod, newdata=df_edges, type='response')
  Y_hat_egoalter_passed = sum(
    df_edges$outdeg_inv_ego *
    df_edges$Y_ego_hat *
    df_edges$Y_nbr_hat
  )

  # with weights
  if (FALSE) {
    ego_wghts = glm(
      gt_ego ~ X_ego + X_nbr + outdeg_ego + indeg_nbr + outdeg_inv_ego + outdeg_inv_nbr,
      family='binomial',
      data=df_edges
    )
    nbr_wghts = glm(
      gt_nbr ~ X_ego + X_nbr + outdeg_ego + indeg_nbr + outdeg_inv_ego + outdeg_inv_nbr,
      family='binomial',
      data=df_edges
    )
    
    ego_mod = glm(
      Y_ego ~ X_ego + X_nbr + outdeg_ego + indeg_nbr +  outdeg_inv_ego,
      family='binomial',
      data=df_edges %>%
        filter(gt_ego == 1),
      weights=1/predict(ego_wghts, type='response', newdata=df_edges[which(df_edges$gt_ego == 1),])
        # 1/outdeg_ego
      #df_edges %>%
      #  filter(gt_ego == 1) %>%
      #  group_by(from) %>%
      #  summarize(
      #    Y_ego=mean(Y_ego),
      #    X_ego=mean(X_ego),
      #    X_nbr=mean(X_nbr),
      #    outdeg_inv_ego=mean(outdeg_inv_ego),
      #    outdeg_ego=mean(outdeg_ego),
      #    indeg_nbr=mean(indeg_nbr)
    )
    df_edges$Y_ego_hat = predict(ego_mod, newdata=df_edges, type='response')
    nbr_mod = glm(
      Y_nbr ~ X_ego + X_nbr + outdeg_inv_ego + Y_ego_hat,
      family='binomial',
      data=df_edges %>%
        filter(gt_nbr == 1),
      weights=1/predict(nbr_wghts, type='response', newdata=df_edges[which(df_edges$gt_nbr == 1),])
      #df_edges %>%
      #  filter(gt_nbr == 1) %>%
      #  group_by(to) %>%
      #  summarize(
      #    Y_nbr=mean(Y_nbr),
      #    X_ego=mean(X_ego),
      #    X_nbr=mean(X_nbr),
      #    outdeg_inv_ego=mean(outdeg_inv_ego),
      #    outdeg_ego=mean(outdeg_ego),
      #    indeg_nbr=mean(indeg_nbr),
      #    Y_ego_hat=mean(Y_ego_hat)
      #  )
    )
  }
  # True values in the network
  Y_true = sum(df_edges$outdeg_inv_ego * df_edges$Y)
  return(
    data.frame(
      Y_true=Y_true,
      Y_hat_node_nonetwork=Y_hat_node_nonetwork,
      Y_hat_node=Y_hat_node,
      Y_hat_edge=Y_hat_edge,
      Y_hat_egoalter=Y_hat_egoalter,
      Y_hat_egoalter_passed=Y_hat_egoalter_passed
    )
  )
}


fn_compute_performance_metrics = function(true_vals, probs) {
  auc_val = as.numeric(auc(roc(true_vals, probs)))
  # zero-one predictions
  preds = probs > 0.5
  prec_val = sum(true_vals * preds) / sum(preds)
  rec_val = sum(true_vals * preds) / sum(true_vals)
  acc_val = sum(true_vals == preds) / length(true_vals)
  return(
    data.frame(
      auc=auc_val,
      precision=prec_val,
      recall=rec_val,
      accuracy=acc_val
    )
  )
}

fn_performance = function(fn_g) {
  # fit models, evlauate performance metrics
  # node no network features (baseline)
  # node
  # edge
  # ego-then-alter
  # ego-then-alter (with prob passed to alter model)
  
  g = fn_g()
  df_nodes = g %>% activate(nodes) %>% as_tibble()
  df_edges = g %>% activate(edges) %>% as_tibble()

  # node no network features
  node_mod = glm(
    Y ~ X, # + log1p(outdeg),
    family='binomial',
    data=df_nodes %>%
      filter(gt == 1)
  )
  node_preds = predict(
    node_mod,
    newdata=df_nodes %>%
      filter(gt == 0),
    type='response',
  )
  node_nonetwork_perf = fn_compute_performance_metrics(
    df_nodes %>%
      filter(gt == 0) %>%
      .$Y,
    node_preds
  ) %>%
    mutate(
      model='node_nonetwork'
    )
  
  # nodemod
  node_mod = glm(
    Y ~ X + outdeg_inv + outdeg,
    family='binomial',
    data=df_nodes %>%
      filter(gt == 1)
  )
  node_preds = predict(
    node_mod,
    newdata=df_nodes %>%
      filter(gt == 0),
    type='response',
  )
  node_perf = fn_compute_performance_metrics(
    df_nodes %>%
      filter(gt == 0) %>%
      .$Y,
    node_preds
  ) %>%
    mutate(
      model='node'
    )
  
  # ego then alter
  ego_mod = glm(
    Y_ego ~ X_ego + X_nbr + outdeg_ego + indeg_nbr + outdeg_inv_ego,
    family='binomial',
    data=df_edges %>%
      filter(gt_ego == 1)
  )
  df_edges$ego_preds = predict(
    ego_mod,
    newdata=df_edges,
    type='response',
  )
  df_edges = df_edges %>%
    group_by(from) %>%
    summarize(
      gt_ego=mean(gt_ego),
      ego_preds=mean(ego_preds),
      Y_ego=mean(Y_ego)
    )
  print(head(df_edges))
  egoalter_perf = fn_compute_performance_metrics(
    df_edges %>%
      filter(gt_ego == 0) %>%
      .$Y_ego,
    df_edges %>%
      filter(gt_ego == 0) %>%
      .$ego_preds
  ) %>%
    mutate(
      model='egoalter'
    )

  return(
    bind_rows(
      node_perf,
      node_nonetwork_perf,
      egoalter_perf
    )
  )
}
```


```{r}
df_nodesamp_runs = fn_par_bootstrap(fn_oos, 500, fn_dgp_corr_nodesamp) 
write_csv(
  df_nodesamp_runs,
  '/Users/georgeberry/Dropbox/project-autocorr/data/nodesamp_runs.csv'
)
```


```{r}
df_edgesamp_runs = fn_par_bootstrap(fn_oos, 500, fn_dgp_corr_edgesamp)
write_csv(
  df_edgesamp_runs,
  '/Users/georgeberry/Dropbox/project-autocorr/data/edgesamp_runs.csv'
)
```


# Perf

```{r}
df_node_perf = fn_par_bootstrap(fn_performance, 500, fn_dgp_corr_nodesamp)
write_csv(
  df_node_perf,
  '/Users/georgeberry/Dropbox/project-autocorr/data/node_perf.csv'
)
```


```{r}
long = df_node_perf %>%
  gather(
    metric, value, auc:accuracy
  )

t.test(
  long %>% filter(model=='node', metric=='auc') %>% .$value,
  long %>% filter(model=='node_nonetwork', metric=='auc') %>% .$value,
)
t.test(
  long %>% filter(model=='node', metric=='auc') %>% .$value,
  long %>% filter(model=='egoalter', metric=='auc') %>% .$value,
)
```

```{r}
long %>%
  group_by(metric, model) %>%
  summarize(
    value=mean(value)
  )
```


```{r}
df_node_perf %>%
  gather(
    metric, value, auc:accuracy
  ) %>%
  #group_by(model, metric) %>%
  #summarize(
  #  value=mean(value),
  #) %>%
  ggplot(aes(x=metric, y=value, fill=model)) +
  #geom_bar(position='dodge', stat='identity')
  geom_boxplot()
```


```{r}
df_edge_perf = fn_par_bootstrap(fn_performance, 500, fn_dgp_corr_nodesamp)
write_csv(
  df_edge_perf,
  '/Users/georgeberry/Dropbox/project-autocorr/data/edge_perf.csv'
)
```

# Plots

```{r}
df_nodesamp = read_csv('/Users/georgeberry/Dropbox/project-autocorr/data/nodesamp_runs.csv')
df_edgesamp = read_csv('/Users/georgeberry/Dropbox/project-autocorr/data/edgesamp_runs.csv')
```

```{r}
df_nodesamp_abs = df_nodesamp_runs %>%
  mutate(
    Y_hat_node=abs(Y_hat_node - Y_true) / Y_true,
    Y_hat_node_nonetwork=abs(Y_hat_node_nonetwork - Y_true) / Y_true,
    Y_hat_edge=abs(Y_hat_edge - Y_true) / Y_true,
    Y_hat_egoalter=abs(Y_hat_egoalter - Y_true) / Y_true,
    Y_hat_egoalter_passed=abs(Y_hat_egoalter_passed - Y_true) / Y_true,
  ) %>%
  select(
    Y_hat_node,
    Y_hat_node_nonetwork,
    Y_hat_edge,
    Y_hat_egoalter,
    Y_hat_egoalter_passed
  ) %>%
  gather(model, value) %>%
  mutate(
    model=case_when(
      model == 'Y_hat_node_nonetwork' ~ 'Node\n(no network features)',
      model == 'Y_hat_node' ~ 'Node\n(network features)',
      model == 'Y_hat_edge' ~ 'Dyad',
      model == 'Y_hat_egoalter' ~ 'Ego-then-alter',
      model == 'Y_hat_egoalter_passed' ~ 'Ego-then-alter\n(augmented)',
      TRUE ~ 'NA'
    ),
    model=factor(
      model,
      levels=c(
        'Node\n(no network features)',
        'Node\n(network features)',
        'Ego-then-alter',
        'Ego-then-alter\n(augmented)',
        'Dyad'
      )
    )
  )
  

df_nodesamp_bias = df_nodesamp_runs %>%
  mutate(
    Y_hat_node=(Y_hat_node - Y_true) / Y_true,
    Y_hat_node_nonetwork=(Y_hat_node_nonetwork - Y_true) / Y_true,
    Y_hat_edge=(Y_hat_edge - Y_true) / Y_true,
    Y_hat_egoalter=(Y_hat_egoalter - Y_true) / Y_true,
    Y_hat_egoalter_passed=(Y_hat_egoalter_passed - Y_true) / Y_true,
  ) %>%
  select(
    Y_hat_node,
    Y_hat_node_nonetwork,
    Y_hat_edge,
    Y_hat_egoalter,
    Y_hat_egoalter_passed
  ) %>%
  gather(model, value) %>%
  mutate(
    model=case_when(
      model == 'Y_hat_node_nonetwork' ~ 'Node\n(no network features)',
      model == 'Y_hat_node' ~ 'Node\n(network features)',
      model == 'Y_hat_edge' ~ 'Dyad',
      model == 'Y_hat_egoalter' ~ 'Ego-then-alter',
      model == 'Y_hat_egoalter_passed' ~ 'Ego-then-alter\n(augmented)',
      TRUE ~ 'NA'
    ),
    model=factor(
      model,
      levels=c(
        'Node\n(no network features)',
        'Node\n(network features)',
        'Ego-then-alter',
        'Ego-then-alter\n(augmented)',
        'Dyad'
      )
    )
  )

df_edgesamp_abs = df_edgesamp_runs %>%
  mutate(
    Y_hat_node=abs(Y_hat_node - Y_true) / Y_true,
    Y_hat_node_nonetwork=abs(Y_hat_node_nonetwork - Y_true) / Y_true,
    Y_hat_edge=abs(Y_hat_edge - Y_true) / Y_true,
    Y_hat_egoalter=abs(Y_hat_egoalter - Y_true) / Y_true,
    Y_hat_egoalter_passed=abs(Y_hat_egoalter_passed - Y_true) / Y_true,
  ) %>%
  select(
    Y_hat_node,
    Y_hat_node_nonetwork,
    Y_hat_edge,
    Y_hat_egoalter,
    Y_hat_egoalter_passed
  ) %>%
  gather(model, value) %>%
  mutate(
    model=case_when(
      model == 'Y_hat_node_nonetwork' ~ 'Node\n(no network features)',
      model == 'Y_hat_node' ~ 'Node\n(network features)',
      model == 'Y_hat_edge' ~ 'Dyad',
      model == 'Y_hat_egoalter' ~ 'Ego-then-alter',
      model == 'Y_hat_egoalter_passed' ~ 'Ego-then-alter\n(augmented)',
      TRUE ~ 'NA'
    ),
    model=factor(
      model,
      levels=c(
        'Node\n(no network features)',
        'Node\n(network features)',
        'Ego-then-alter',
        'Ego-then-alter\n(augmented)',
        'Dyad'
      )
    )
  )

df_edgesamp_bias = df_edgesamp_runs %>%
  mutate(
    Y_hat_node=(Y_hat_node - Y_true) / Y_true,
    Y_hat_node_nonetwork=(Y_hat_node_nonetwork - Y_true) / Y_true,
    Y_hat_edge=(Y_hat_edge - Y_true) / Y_true,
    Y_hat_egoalter=(Y_hat_egoalter - Y_true) / Y_true,
    Y_hat_egoalter_passed=(Y_hat_egoalter_passed - Y_true) / Y_true,
  ) %>%
  select(
    Y_hat_node,
    Y_hat_node_nonetwork,
    Y_hat_edge,
    Y_hat_egoalter,
    Y_hat_egoalter_passed
  ) %>%
  gather(model, value) %>%
  mutate(
    model=case_when(
      model == 'Y_hat_node_nonetwork' ~ 'Node\n(no network features)',
      model == 'Y_hat_node' ~ 'Node\n(network features)',
      model == 'Y_hat_edge' ~ 'Dyad',
      model == 'Y_hat_egoalter' ~ 'Ego-then-alter',
      model == 'Y_hat_egoalter_passed' ~ 'Ego-then-alter\n(augmented)',
      TRUE ~ 'NA'
    ),
    model=factor(
      model,
      levels=c(
        'Node\n(no network features)',
        'Node\n(network features)',
        'Ego-then-alter',
        'Ego-then-alter\n(augmented)',
        'Dyad'
      )
    )
  )
```

```{r}
fn_plot = function(df) {
  df %>%
    gather(model, value) %>%
    ggplot(aes(x=model, y=value)) +
    geom_boxplot() +
    geom_hline(yintercept=0, linetype='dashed') +
    coord_flip()
}
```


```{r}
df_edgesamp_bias %>%
  gather(model, value) %>%
  ggplot(aes(x=model, y=value)) +
  geom_boxplot() +
  geom_hline(yintercept=0, linetype='dashed') +
  coord_flip()
```

```{r}
df_edgesamp_abs %>%
  gather(model, value) %>%
  ggplot(aes(x=model, y=value)) +
  geom_boxplot() +
  geom_hline(yintercept=0, linetype='dashed') +
  coord_flip()
```

```{r}
df_nodesamp_abs %>%
  gather(model, value) %>%
  ggplot(aes(x=model, y=value)) +
  geom_boxplot() +
  geom_hline(yintercept=0, linetype='dashed') +
  coord_flip()
```

```{r}
df_nodesamp_bias %>%
  gather(model, value) %>%
  ggplot(aes(x=model, y=value)) +
  geom_boxplot() +
  geom_hline(yintercept=0, linetype='dashed') +
  coord_flip()
```


# Misc


```{r}
( mean(res$edge_twomod) - mean(res$node) ) / ( sqrt ( sd(res$edge_twomod)^2 / 1000 + sd(res$node)^2 / 1000  ) )
```

```{r}
sd(res$edge_twomod)
```


```{r}
g = fn_dgp_corr_plus_sampling()
df_nodes = g %>% activate(nodes) %>% as_tibble()
df_edges = g %>% activate(edges) %>% as_tibble()
```

```{r}
df = as.data.frame(
  df_edges %>% select(
    X_ego,
    X_nbr,
    outdeg_ego,
    outdeg_inv_ego,
    indeg_nbr,
    indeg_inv_nbr
  )
)

imbalance(
  group=df_edges$gt_ego,
  data=df
)

```



```{r}
summary(glm(
  Y ~ X_ego + X_nbr,
  family='binomial',
  data=df_edges
))

summary(glm(
  Y ~ X,
  family='binomial',
  data=df_nodes
))
```


```{r}
summary(glm(
  Y_ego ~ X_ego + X_nbr,
  family='binomial',
  data=df_edges
))
```

```{r}
summary(glm(
  Y_ego ~ X_ego + X_nbr,
  family='binomial',
  data=df_edges %>%
    filter(gt_ego == 1),
))
```


```{r}
wghts = glm(
  gt ~ X_ego + X_nbr + outdeg_ego + indeg_nbr + outdeg_inv_ego + outdeg_inv_nbr,
  family='binomial',
  data=df_edges
)

summary(glm(
  Y_ego ~ X_ego + X_nbr,
  family='binomial',
  data=df_edges %>%
    filter(gt_ego == 1),
  weights=1/predict(wghts, type='response', newdata=df_edges %>%
    filter(gt_ego == 1)),
))
```

try some weights out

```{r}
library(anesrake)

qcut = function(col) {
  return(
    cut(col, quantile(col, probs=seq(0, 1, by=0.25)))
  )
}

df = df_edges %>%
  select(
    X_ego,
    X_nbr,
    outdeg_ego,
    indeg_nbr,
    outdeg_inv_ego,
    outdeg_inv_nbr,
  ) %>%
  mutate_all(qcut)

#levels(df$X_ego) = c('very low', 'low', 'high', 'very high')
#levels(df$X_nbr) = c('very low', 'low', 'high', 'very high')

make_input_list = function(col) {
  return(wpct(col))
}

marginals = with(df, list(
    X_ego=wpct(X_ego),
    X_nbr=wpct(X_nbr),
    outdeg_ego=wpct(outdeg_ego),
    indeg_nbr=wpct(indeg_nbr) # ,
    #outdeg_inv_ego=wpct(outdeg_inv_ego),
    #outdeg_inv_nbr=wpct(outdeg_inv_nbr)
))

df = as.data.frame(df)[which(df_edges$gt_ego == 1),]
rownames(df) = 1:nrow(df)

raking = anesrake(
  marginals,
  df,
  1:nrow(df),
  pctlim=0.01,
  convcrit=0.005
  # weightvec=1/df_edges[which(df_edges$gt_ego == 1),]$outdeg_ego
)
```

```{r}
summary(raking)
```



```{r}
summary(lm(
  Y_ego ~ X_ego + X_nbr,
  #family='binomial',
  data=df_edges
))

summary(lm(
  Y_ego ~ X_ego + X_nbr,
  #family='binomial',
  data=df_edges %>%
    filter(gt_ego == 1),
  weights=1/df_edges[which(df_edges$gt_ego == 1),]$outdeg_ego,
))

summary(lm(
  Y_ego ~ X_ego + X_nbr,
  #family='binomial',
  data=df_edges %>%
    filter(gt_ego == 1),
  weights=raking$weightvec,
))

summary(lm(
  Y_ego ~ X_ego + X_nbr,
  #family='binomial',
  data=df_edges %>%
    filter(gt_ego == 1),
  #weights=raking$weightvec  * 1/df_edges[which(df_edges$gt_ego == 1),]$outdeg_ego,
))

wghts_ego = glm(
  gt_ego ~ X_ego + X_nbr + outdeg_ego + indeg_nbr + outdeg_inv_ego + outdeg_inv_nbr,
  family='binomial',
  data=df_edges
)

summary(lm(
  Y_ego ~ X_ego + X_nbr,
  # family='binomial',
  data=df_edges %>%
    filter(gt_ego == 1),
  weights=1/predict(wghts, type='response', newdata=df_edges %>%
    filter(gt_ego == 1)),
))
```


## Other specs

```{r}
fn_dgp_indep_nodesamp = function(size=4000) {
  # Creates a graph and draws Y = f(X), where X ~ N(0, 1)
  # Draws gt == 1 for about 10% of the nodes
  g = play_barabasi_albert(size, 0.8, 5)
  g = g %>%
    bind_edges(
      g %>%
        activate(edges) %>%
        as_tibble() %>%
        mutate(tmp=to, to=from, from=tmp) %>%
        select(to, from)
    ) %>%
    activate(nodes) %>%
    mutate(
      X = rnorm(n()),
      Y_prob_true = 1 / (1 + exp(- 2 * X)),
      outdeg = centrality_degree(mode='out'),
      outdeg_inv = 1 / outdeg,
      indeg = centrality_degree(mode='in'),
      indeg_inv = 1 / indeg,
      Y = rbinom(
        n(),
        1,
        Y_prob_true
      ),
      gt = rbinom(n(), 1, 0.2)
    ) %>%
    activate(edges) %>%
    mutate(
      Y_ego = .N()$Y[from],
      Y_nbr = .N()$Y[to],
      Y = Y_ego * Y_nbr,
      indeg_ego = .N()$indeg[from],
      indeg_nbr = .N()$indeg[to],
      outdeg_ego = .N()$outdeg[from],
      outdeg_nbr = .N()$outdeg[to],
      indeg_inv_ego = .N()$indeg_inv[from],
      indeg_inv_nbr = .N()$indeg_inv[to],
      outdeg_inv_ego = .N()$outdeg_inv[from],
      outdeg_inv_nbr = .N()$outdeg_inv[to],
      gt_ego = .N()$gt[from],
      gt_nbr = .N()$gt[to],
      gt = as.numeric(gt_ego & gt_nbr),
      X_ego = .N()$X[from],
      X_nbr = .N()$X[to],
    )
  return(g)
}



fn_dgp_corr_edgesamp = function(size=4000) {
  # Creates a graph and draws Y = f(X, Z), where X ~ N(0, 1) and
  # Z is the ego-network avg of the observed X
  g = play_barabasi_albert(size, 0.8, 5)
  g = g %>%
    bind_edges(
      g %>%
        activate(edges) %>%
        as_tibble() %>%
        mutate(tmp=to, to=from, from=tmp) %>%
        select(to, from)
    ) %>%
    activate(nodes) %>%
    mutate(
      X = rnorm(n()),
      # ZZ = rnorm(n()), 
      Z = map_local_dbl(
        .f = function(neighborhood, ...) {
          max(as_tibble(neighborhood, active='nodes')$X)
        }
      ),
      Z = (Z - mean(Z)) / sd(Z),
      outdeg = centrality_degree(mode='out'),
      Y_prob_true = 1 / (1 + exp(- 2 * X - Z)),
      outdeg_inv = 1 / outdeg,
      indeg = centrality_degree(mode='in'),
      indeg_inv = 1 / indeg,
      Y = rbinom(
        n(),
        1,
        Y_prob_true
      ),
      gt = rbinom(n(), 1, 0.2)
    ) %>%
    activate(edges) %>%
    mutate(
      Y_ego = .N()$Y[from],
      Y_nbr = .N()$Y[to],
      Y = Y_ego * Y_nbr,
      indeg_ego = .N()$indeg[from],
      indeg_nbr = .N()$indeg[to],
      outdeg_ego = .N()$outdeg[from],
      outdeg_nbr = .N()$outdeg[to],
      indeg_inv_ego = .N()$indeg_inv[from],
      indeg_inv_nbr = .N()$indeg_inv[to],
      outdeg_inv_ego = .N()$outdeg_inv[from],
      outdeg_inv_nbr = .N()$outdeg_inv[to],
      gt_ego = .N()$gt[from],
      gt_nbr = .N()$gt[to],
      gt = as.numeric(gt_ego & gt_nbr),
      X_ego = .N()$X[from],
      X_nbr = .N()$X[to],
    )
  return(g)
}

fn_dgp_corr_omitted_nodesamp = function(size=4000) {
  # Creates a graph and draws Y = f(X, Z), where X ~ N(0, 1) and
  # Z is the ego-network avg of an unobserved ZZ ~ N(0, 1)
  # Both Z and ZZ are unobserved
  g = play_barabasi_albert(size, 0.8, 5)
  g = g %>%
    bind_edges(
      g %>%
        activate(edges) %>%
        as_tibble() %>%
        mutate(tmp=to, to=from, from=tmp) %>%
        select(to, from)
    ) %>%
    activate(nodes) %>%
    mutate(
      X = rnorm(n()),
      ZZ = rnorm(n()), 
      Z = map_local_dbl(
        .f = function(neighborhood, ...) {
          max(as_tibble(neighborhood, active='nodes')$ZZ)
        }
      ),
      Z = (Z - mean(Z)) / sd(Z),
      outdeg = centrality_degree(mode='out'),
      Y_prob_true = 1 / (1 + exp(- 2 * X - Z)),
      outdeg_inv = 1 / outdeg,
      indeg = centrality_degree(mode='in'),
      indeg_inv = 1 / indeg,
      Y = rbinom(
        n(),
        1,
        Y_prob_true
      ),
      gt = rbinom(n(), 1, 0.2)
    ) %>%
    activate(edges) %>%
    mutate(
      Y_ego = .N()$Y[from],
      Y_nbr = .N()$Y[to],
      Y = Y_ego * Y_nbr,
      indeg_ego = .N()$indeg[from],
      indeg_nbr = .N()$indeg[to],
      outdeg_ego = .N()$outdeg[from],
      outdeg_nbr = .N()$outdeg[to],
      indeg_inv_ego = .N()$indeg_inv[from],
      indeg_inv_nbr = .N()$indeg_inv[to],
      outdeg_inv_ego = .N()$outdeg_inv[from],
      outdeg_inv_nbr = .N()$outdeg_inv[to],
      gt_ego = .N()$gt[from],
      gt_nbr = .N()$gt[to],
      gt = as.numeric(gt_ego & gt_nbr),
      X_ego = .N()$X[from],
      X_nbr = .N()$X[to],
    )
  return(g)
}

fn_dgp_corr_plus_sampling = function(size=4000) {
  # Creates a graph and draws Y = f(X, Z), where X ~ N(0, 1) and
  # Z is the ego-network avg of an unobserved ZZ ~ N(0, 1)
  # Both Z and ZZ are unobserved
  # Then draws gt = f(X, Z, Q), where Q ~ N(0, 1) and 
  # both Z and Q are unobserved
  g = play_barabasi_albert(size, 0.8, 5)
  g = g %>%
    bind_edges(
      g %>%
        activate(edges) %>%
        as_tibble() %>%
        mutate(tmp=to, to=from, from=tmp) %>%
        select(to, from)
    ) %>%
    activate(nodes) %>%
    mutate(
      X = rnorm(n()),
      # ZZ = rnorm(n()), 
      Z = map_local_dbl(
        .f = function(neighborhood, ...) {
          max(as_tibble(neighborhood, active='nodes')$X)
        }
      ),
      Z = (Z - mean(Z)) / sd(Z),
      Y_prob_true = 1 / (1 + exp(- 2 * X - Z)),
      outdeg = centrality_degree(mode='out'),
      outdeg_inv = 1 / outdeg,
      indeg = centrality_degree(mode='in'),
      indeg_inv = 1 / indeg,
      Y = rbinom(
        n(),
        1,
        Y_prob_true
      ),
      Q = rnorm(n()),
      # probably we see the true value
      Q_prob = 1 / (1 + exp(-2*Q - X)),
      gt = as.integer(
        rank(Q_prob) > 0.8 * size
      )
      #gt = rbinom(
      #  n(),
      #  1,
      #  Q_prob
      #)
    ) %>%
    activate(edges) %>%
    mutate(
      Y_ego = .N()$Y[from],
      Y_nbr = .N()$Y[to],
      Y = Y_ego * Y_nbr,
      indeg_ego = .N()$indeg[from],
      indeg_nbr = .N()$indeg[to],
      outdeg_ego = .N()$outdeg[from],
      outdeg_nbr = .N()$outdeg[to],
      indeg_inv_ego = .N()$indeg_inv[from],
      indeg_inv_nbr = .N()$indeg_inv[to],
      outdeg_inv_ego = .N()$outdeg_inv[from],
      outdeg_inv_nbr = .N()$outdeg_inv[to],
      Q_ego = .N()$Q[from],
      Q_nbr = .N()$Q[to],
      Q_prob_ego = .N()$Q_prob[from],
      Q_prob_nbr = .N()$Q_prob[to],
      gt_ego = .N()$gt[from],
      gt_nbr = .N()$gt[to],
      gt = as.numeric(gt_ego & gt_nbr),
      X_ego = .N()$X[from],
      X_nbr = .N()$X[to]
    )
  return(g)
}


```


#### scratch

```{r}
# Both Z and ZZ are unobserved
g = play_barabasi_albert(20, 0.8, 2)
g = g %>%
  activate(edges) %>%
  mutate(
    gt_ego = rbinom(n(), 1, 0.5),
    gt_nbr = gt_ego,
  ) %>%
  activate(nodes) %>%
  mutate(
    gt=map_local_dbl(
      .f = function(neighborhood, node, ...) {
        print(node)
        print(as_tibble(neighborhood, active='edges') %>% mutate(idx=node))
        as_tibble(neighborhood, active='edges') %>%
          #filter(
          #  (from == node) | (to == node),
          #  gt_ego==1
          #) %>%
          nrow()
        # print(node)
        # print(tmp_edge_df)
        # min(nrow(tmp_edge_df), 1)
      }
    )
  )
tmp = g %>% activate(nodes) %>% as_tibble()
tmp$gt
```